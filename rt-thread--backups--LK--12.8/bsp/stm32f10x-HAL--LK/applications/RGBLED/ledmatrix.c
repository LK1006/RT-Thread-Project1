#include <stdlib.h>
#include <string.h>

#include "ledmatrix.h"
#include "morphdigit.h"

#define ROW_D GPIO_PIN_9
#define ROW_C GPIO_PIN_3
#define ROW_B GPIO_PIN_10
#define ROW_A GPIO_PIN_4

#define ROW_0       GPIOA->BSRR = (ROW_D << 16) | (ROW_C << 16) | (ROW_B << 16) | (ROW_A << 16);
#define ROW_1       GPIOA->BSRR = (ROW_D << 16) | (ROW_C << 16) | (ROW_B << 16) | ROW_A;
#define ROW_2       GPIOA->BSRR = (ROW_D << 16) | (ROW_C << 16) | ROW_B         | (ROW_A << 16);
#define ROW_3       GPIOA->BSRR = (ROW_D << 16) | (ROW_C << 16) | ROW_B         | ROW_A;
#define ROW_4       GPIOA->BSRR = (ROW_D << 16) | ROW_C         | (ROW_B << 16) | (ROW_A << 16);
#define ROW_5       GPIOA->BSRR = (ROW_D << 16) | ROW_C         | (ROW_B << 16) | ROW_A;
#define ROW_6       GPIOA->BSRR = (ROW_D << 16) | ROW_C         | ROW_B         | (ROW_A << 16);
#define ROW_7       GPIOA->BSRR = (ROW_D << 16) | ROW_C         | ROW_B         | ROW_A;
#define ROW_8       GPIOA->BSRR = ROW_D         | (ROW_C << 16) | (ROW_B << 16) | (ROW_A << 16);
#define ROW_9       GPIOA->BSRR = ROW_D         | (ROW_C << 16) | (ROW_B << 16) | ROW_A;
#define ROW_10      GPIOA->BSRR = ROW_D         | (ROW_C << 16) | ROW_B         | (ROW_A << 16);
#define ROW_11      GPIOA->BSRR = ROW_D         | (ROW_C << 16) | ROW_B         | ROW_A;
#define ROW_12      GPIOA->BSRR = ROW_D         | ROW_C         | (ROW_B << 16) | (ROW_A << 16);
#define ROW_13      GPIOA->BSRR = ROW_D         | ROW_C         | (ROW_B << 16) | ROW_A;
#define ROW_14      GPIOA->BSRR = ROW_D         | ROW_C         | ROW_B         | (ROW_A << 16);
#define ROW_15      GPIOA->BSRR = ROW_D         | ROW_C         | ROW_B         | ROW_A;

#define LAT_LE_H    GPIOB->BSRR = GPIO_PIN_9;
#define LAT_LOCK    GPIOB->BSRR = (GPIO_PIN_9 << 16);

#define DAT_R1(x)    {HAL_GPIO_WritePin(GPIOA,GPIO_PIN_8,x);}
#define DAT_G1(x)    {HAL_GPIO_WritePin(GPIOB,GPIO_PIN_7,x);}
#define DAT_B1(x)    {HAL_GPIO_WritePin(GPIOA,GPIO_PIN_7,x);}

#define DAT_R2(x)    {HAL_GPIO_WritePin(GPIOA,GPIO_PIN_6,x);}
#define DAT_G2(x)    {HAL_GPIO_WritePin(GPIOB,GPIO_PIN_6,x);}
#define DAT_B2(x)    {HAL_GPIO_WritePin(GPIOA,GPIO_PIN_5,x);}

#define CTRL_CLK(x)  {HAL_GPIO_WritePin(GPIOA,GPIO_PIN_1,x);}
//#define CTRL_LAT(x)  {HAL_GPIO_WritePin(GPIOC,GPIO_PIN_4,x);}
//#define CTRL_OE(x)   {HAL_GPIO_WritePin(GPIOA,GPIO_PIN_10,x);}

dat_rgb_t dat;

uint8_t line[]   = {0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF};

/* 以下图像取模为逐行式，图像大小设置为64*32*/
uint8_t gap[]    = {0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00,\
                    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\
                    0x00,0x00,0x40,0x20,0x20,0x20,0x10,0x10,0x08,0x08,0x08,0x04,0x04,0x02,0x02,0x00};

										
uint8_t calendar_led[] = {0x08,0x08,0xF8,0x04,0x04,0x02,0xF8,0x08,0x08,0x08,0xFF,0x00,0x00,0x00,0x00,0x00,
                      0x00,0x00,0x3F,0x01,0x01,0x01,0x1F,0x01,0x01,0x01,0x7F,0x01,0x01,0x01,0x01,0x01,/*"年",0*/
                      0x00,0xF8,0x08,0x08,0x08,0xF8,0x08,0x08,0x08,0xF8,0x08,0x08,0x04,0x04,0x02,0x01,
                      0x00,0x1F,0x10,0x10,0x10,0x1F,0x10,0x10,0x10,0x1F,0x10,0x10,0x10,0x10,0x14,0x08,/*"月",1*/
                      0x00,0xF8,0x08,0x08,0x08,0x08,0x08,0xF8,0x08,0x08,0x08,0x08,0x08,0x08,0xF8,0x08,
                      0x00,0x0F,0x08,0x08,0x08,0x08,0x08,0x0F,0x08,0x08,0x08,0x08,0x08,0x08,0x0F,0x08,/*"日",2*/
                      0x00,0xF8,0x08,0xF8,0x08,0xF8,0x80,0x88,0xF8,0x84,0x82,0xF8,0x80,0x80,0xFE,0x00,
                      0x00,0x0F,0x08,0x0F,0x08,0x0F,0x00,0x00,0x1F,0x00,0x00,0x0F,0x00,0x00,0x3F,0x00,/*"星",3*/
                      0x44,0x44,0xFE,0x44,0x44,0x7C,0x44,0x44,0x7C,0x44,0x44,0xFF,0x20,0x44,0x82,0x41,
                      0x00,0x3E,0x22,0x22,0x22,0x3E,0x22,0x22,0x22,0x3E,0x22,0x22,0x21,0x21,0x28,0x10};/*"期",4*/


uint8_t weekday[] = {0x00,0xF8,0x08,0x08,0x08,0x08,0x08,0xF8,0x08,0x08,0x08,0x08,0x08,0x08,0xF8,0x08,
                     0x00,0x0F,0x08,0x08,0x08,0x08,0x08,0x0F,0x08,0x08,0x08,0x08,0x08,0x08,0x0F,0x08,/*"日",0*/
                     0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
                     0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,/*"一",1*/
                     0x00,0x00,0x00,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00,
                     0x00,0x00,0x00,0x1F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7F,0x00,0x00,0x00,/*"二",2*/
                     0x00,0x00,0xFE,0x00,0x00,0x00,0x00,0xFC,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0x00,
                     0x00,0x00,0x3F,0x00,0x00,0x00,0x00,0x1F,0x00,0x00,0x00,0x00,0x00,0x7F,0x00,0x00,/*"三",3*/
                     0x00,0x00,0xFE,0x22,0x22,0x22,0x22,0x22,0x12,0x12,0x0A,0x06,0x02,0xFE,0x02,0x00,
                     0x00,0x00,0x3F,0x22,0x22,0x22,0x22,0x22,0x22,0x3C,0x20,0x20,0x20,0x3F,0x20,0x00,/*"四",4*/
                     0x00,0xFE,0x40,0x40,0x40,0x40,0xFC,0x20,0x20,0x20,0x20,0x10,0x10,0x10,0xFF,0x00,
                     0x00,0x3F,0x00,0x00,0x00,0x00,0x0F,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x7F,0x00,/*"五",5*/
                     0x40,0x80,0x00,0x00,0x00,0xFF,0x00,0x00,0x20,0x20,0x10,0x10,0x08,0x04,0x02,0x00,
                     0x00,0x00,0x01,0x01,0x00,0x7F,0x00,0x00,0x02,0x04,0x08,0x10,0x10,0x20,0x20,0x00};/*"六",6*/

uint8_t rect[]   = {0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x80,\
                    0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x80,\
                    0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x80,\
                    0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x80,\
                    0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x80,\
                    0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x80,\
                    0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x80,\
                    0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x80,\
                    0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x80,\
                    0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x80,\
                    0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x80,\
                    0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x80,\
                    0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x80,\
                    0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x80,\
                    0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x80,\
                    0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF};/* rect */

uint8_t ship[]    ={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFC,0xFC,0xFD,0x01,0x00,0x00,0x1E,0x00,
                    0x04,0x21,0x20,0x00,0x00,0x00,0x77,0x00,0x04,0x21,0x20,0x00,0x00,0x00,0x63,0x00,
                    0x04,0x21,0x20,0x00,0x00,0x78,0x3E,0x00,0xFC,0x20,0x20,0x00,0x00,0x48,0x00,0x00,
                    0x34,0x20,0x20,0x00,0xE0,0x79,0xC0,0x01,0x44,0x20,0x20,0x00,0xE0,0x01,0x40,0x0F,
                    0x84,0x20,0x20,0x00,0xF0,0x00,0x40,0x38,0x04,0x21,0x20,0x00,0x90,0x07,0x40,0x20,
                    0x00,0x00,0x00,0x00,0x90,0x05,0xC0,0x21,0x00,0x00,0x00,0xE0,0xFF,0x0F,0x40,0x2F,
                    0x00,0x00,0x00,0xFF,0x11,0x18,0x40,0x38,0xF0,0x7F,0x80,0xBF,0xCF,0x1B,0x40,0x00,
                    0x70,0x7B,0xC0,0xA1,0x4C,0x32,0x40,0x00,0xF0,0xFF,0xF3,0xA1,0xCF,0xE3,0xFF,0x00,
                    0xF0,0x7F,0xDE,0xA0,0xFF,0xCF,0xD7,0x00,0xE0,0x7B,0xFC,0xFF,0xFF,0xFF,0x7F,0x00,
                    0xE0,0x2F,0xF8,0x7F,0x3C,0x1E,0x30,0x00,0x40,0x00,0x00,0xDC,0x66,0x33,0x10,0x00,
                    0xC0,0x00,0x00,0x84,0x42,0x21,0x18,0x00,0x80,0x01,0x00,0x8C,0x42,0x31,0x08,0x00,
                    0x00,0x01,0x00,0xF8,0x7E,0x1F,0x0C,0x00,0x00,0xF3,0xFF,0xFF,0xFF,0xFF,0x07,0x00,
                    0x00,0x3E,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x0C,0x00,0x00,0x00,0x00,0x07,0x00,
                    0x00,0x18,0x03,0x30,0xC0,0x00,0x07,0x38,0x60,0x90,0x07,0x78,0xF0,0x83,0x0F,0x78,
                    0xF0,0xF0,0x3D,0xDE,0x7F,0xFE,0xF8,0xFF,0xBE,0xFF,0xF3,0x3F,0xF0,0x01,0xC7,0x39,
                    0x7B,0x66,0x7E,0xFF,0x3F,0xFF,0xFF,0xFF,0xCE,0x3F,0xF8,0x01,0x07,0x00,0xE0,0xC0};

uint8_t happy[]   ={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x38,0x0E,
                    0x06,0x03,0x00,0x00,0x00,0x00,0x7E,0x3F,0x06,0x03,0x00,0x00,0x00,0x00,0xFE,0x3F,
                    0x06,0x03,0x00,0x00,0x00,0x00,0xEF,0x7B,0x06,0xE3,0xE3,0xC7,0xCF,0x31,0xC7,0x71,
                    0xFE,0xE3,0xE7,0xCF,0x9F,0x31,0xC7,0x71,0xFE,0x03,0x66,0xCC,0x98,0x19,0x07,0x70,
                    0x06,0xE3,0x67,0xCC,0x98,0x19,0x07,0x70,0x06,0x33,0x66,0xCC,0x18,0x1B,0x0E,0x38,
                    0x06,0x33,0x67,0xCC,0x18,0x0F,0x1E,0x38,0x06,0xF3,0xE7,0xC7,0x0F,0x0F,0x1C,0x3C,
                    0x06,0xE3,0xE6,0xC7,0x0F,0x0E,0x3C,0x1E,0x00,0x00,0x60,0xC0,0x00,0x06,0x78,0x0F,
                    0x00,0x00,0x60,0xC0,0x00,0x07,0xF0,0x07,0x00,0x00,0x60,0xC0,0xC0,0x03,0xE0,0x03,
                    0xF0,0x03,0x00,0x00,0xC0,0x01,0xC0,0x01,0xF0,0xC7,0x01,0xC6,0x00,0x30,0x00,0x00,
                    0x30,0x06,0x00,0xC6,0x00,0x30,0x00,0x00,0x30,0xC6,0x6C,0xDF,0x0F,0x3E,0x9F,0x63,
                    0xF0,0xC3,0x7C,0xDF,0x1F,0x3F,0x3F,0x63,0xF0,0xC7,0x1C,0xC6,0x98,0x31,0x30,0x33,
                    0x30,0xCC,0x0C,0xC6,0x98,0x31,0x3F,0x33,0x30,0xCC,0x0C,0xC6,0x98,0xB1,0x31,0x36,
                    0x30,0xCC,0x0C,0xC6,0x98,0xB1,0x39,0x1E,0xF0,0xC7,0x0C,0xDE,0x98,0xBF,0x3F,0x1E,
                    0xF0,0xC3,0x0C,0xDC,0x18,0x37,0x37,0x1C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0C,
                    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0E,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x07,
                    0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};

uint8_t zhufu[]   ={0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0C,0x00,0x60,0x06,0x60,0x06,0x00,0x00,
                    0x98,0x3F,0x60,0x06,0x60,0x06,0x00,0x00,0x80,0x21,0xFE,0x7F,0xFE,0x7F,0x00,0x00,
                    0xBE,0x21,0x60,0x06,0x60,0x06,0x00,0x00,0x90,0x21,0x60,0x06,0x60,0x06,0x00,0x00,
                    0x98,0x21,0xFC,0x3F,0xFC,0x3F,0x00,0x00,0xBC,0x3F,0x04,0x20,0x04,0x20,0x00,0x00,
                    0x6E,0x0A,0xFE,0x2F,0xFE,0x2F,0x00,0x00,0x0A,0x0B,0x80,0x01,0x80,0x01,0x00,0x00,
                    0x08,0x0B,0x80,0x01,0x80,0x01,0x00,0x00,0x08,0x09,0xF8,0x1F,0xF8,0x1F,0x00,0x00,
                    0x88,0x49,0x80,0x0F,0x80,0x0F,0x00,0x00,0xC8,0xC8,0x80,0x09,0x80,0x09,0x00,0x00,
                    0x78,0x78,0xFE,0x7F,0xFE,0x7F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
                    0x00,0x30,0x00,0x00,0x30,0x0C,0x00,0x00,0x00,0x30,0x00,0x00,0x10,0x0C,0x00,0x30,
                    0x00,0x32,0xC0,0xFF,0x10,0x0C,0xF0,0x7F,0x00,0x33,0x40,0xC0,0x74,0x7F,0x30,0x01,
                    0x00,0xFF,0x47,0xC0,0x7C,0x6C,0x10,0x03,0x00,0x31,0x40,0xC0,0x54,0x6C,0x10,0x03,
                    0x80,0x31,0x40,0xC0,0x14,0x6C,0x10,0x03,0xC0,0x30,0xC0,0xFF,0x14,0x64,0xF8,0x7F,
                    0x00,0xFF,0x43,0xC0,0xD0,0xFF,0x00,0x03,0x00,0x30,0x40,0xC0,0x10,0x0C,0x60,0x1B,
                    0x00,0x30,0x40,0xC0,0x10,0x1E,0x20,0x33,0x00,0x30,0x40,0xC0,0x10,0x33,0x30,0x33,
                    0x00,0x30,0x40,0xC0,0x90,0x61,0x18,0x63,0xC0,0xFF,0xCF,0xFF,0xF0,0xC0,0xCC,0x43,
                    0x00,0x00,0x40,0xC0,0x50,0x00,0x80,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};

uint8_t kands[]  = {0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x80,
                    0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x80,
                    0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x80,
                    0xE1,0x80,0x0F,0x38,0x70,0x00,0xF8,0x87,0xE1,0xC0,0x07,0xFE,0xFC,0x01,0xFE,0x87,
                    0xE1,0xE0,0x03,0xFF,0xFF,0x03,0xFF,0x87,0xE1,0xF0,0x01,0xEF,0x9F,0x83,0x0F,0x84,
                    0xE1,0xF0,0x80,0x87,0x8F,0x87,0x07,0x80,0xE1,0xF8,0x80,0x83,0x07,0x87,0x07,0x80,
                    0xE1,0x7C,0x80,0x03,0x03,0x87,0x0F,0x80,0xE1,0x3E,0x80,0x03,0x00,0x87,0x3F,0x80,
                    0xE1,0x1F,0x80,0x03,0x00,0x07,0xFF,0x80,0xE1,0x1F,0x00,0x07,0x80,0x07,0xFE,0x83,
                    0xE1,0x1F,0x00,0x07,0x80,0x03,0xF8,0x87,0xE1,0x3E,0x00,0x0F,0xC0,0x03,0xE0,0x87,
                    0xE1,0x7C,0x00,0x0E,0xC0,0x01,0x80,0x8F,0xE1,0xFC,0x00,0x1E,0xE0,0x01,0x00,0x8F,
                    0xE1,0xF8,0x01,0x3C,0xF0,0x00,0x00,0x8F,0xE1,0xF0,0x01,0x78,0x78,0x80,0x00,0x8F,
                    0xE1,0xE0,0x03,0xF0,0x3D,0x80,0x83,0x8F,0xE1,0xC0,0x07,0xE0,0x1F,0x80,0xFF,0x87,
                    0xE1,0xC0,0x0F,0xC0,0x0F,0x80,0xFF,0x83,0xE1,0x80,0x1F,0x00,0x03,0x00,0xFF,0x80,
                    0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x80,
                    0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x80,
                    0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF};

uint8_t zhongqiu[] ={0x80,0x80,0x80,0x80,0xFC,0x84,0x84,0x84,0x84,0x84,0xFC,0x84,0x80,0x80,0x80,0x80,
                    0x00,0x00,0x00,0x00,0x1F,0x10,0x10,0x10,0x10,0x10,0x1F,0x10,0x00,0x00,0x00,0x00,/*"中",0*/
                    0x10,0x38,0x0F,0x08,0x88,0xBF,0x88,0x4C,0x1C,0x2A,0x2A,0x09,0x88,0x88,0x48,0x28,
                    0x02,0x02,0x02,0x02,0x22,0x22,0x12,0x0A,0x02,0x05,0x05,0x09,0x08,0x10,0x20,0x40,/*"秋",1*/
                    0x08,0x08,0x08,0xC8,0x18,0x2A,0x0A,0x0A,0xE9,0x08,0x08,0x08,0x88,0x88,0x48,0x28,
                    0x02,0x02,0x02,0x1F,0x12,0x12,0x12,0x12,0x7F,0x02,0x05,0x05,0x08,0x08,0x10,0x60,/*"快",2*/
                    0x00,0x00,0xF8,0x08,0x88,0x84,0x84,0xFC,0x80,0x90,0x90,0x88,0x84,0x82,0xA0,0x40,
                    0x04,0x0F,0x00,0x00,0x00,0x00,0x00,0x3F,0x00,0x04,0x08,0x10,0x20,0x20,0x00,0x00};/*"乐",3*/


/* 0~9 */
uint8_t num[]    = {0x00,0x00,0x00,0x18,0x24,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x24,0x18,0x00,0x00,\
                    0x00,0x00,0x00,0x10,0x1C,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x7C,0x00,0x00,\
                    0x00,0x00,0x00,0x3C,0x42,0x42,0x42,0x40,0x20,0x10,0x08,0x04,0x42,0x7E,0x00,0x00,\
                    0x00,0x00,0x00,0x3C,0x42,0x42,0x40,0x20,0x18,0x20,0x40,0x42,0x42,0x3C,0x00,0x00,\
                    0x00,0x00,0x00,0x20,0x30,0x30,0x28,0x24,0x24,0x22,0xFE,0x20,0x20,0xF8,0x00,0x00,\
                    0x00,0x00,0x00,0x7E,0x02,0x02,0x02,0x1E,0x22,0x40,0x40,0x42,0x22,0x1C,0x00,0x00,\
                    0x00,0x00,0x00,0x18,0x24,0x02,0x02,0x3A,0x46,0x42,0x42,0x42,0x44,0x38,0x00,0x00,\
                    0x00,0x00,0x00,0x7E,0x42,0x20,0x20,0x10,0x10,0x08,0x08,0x08,0x08,0x08,0x00,0x00,\
                    0x00,0x00,0x00,0x3C,0x42,0x42,0x42,0x24,0x18,0x24,0x42,0x42,0x42,0x3C,0x00,0x00,\
                    0x00,0x00,0x00,0x1C,0x22,0x42,0x42,0x42,0x62,0x5C,0x40,0x40,0x24,0x18,0x00,0x00};


										
uint8_t AA[]     ={0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};/*"?????",0*/




/*
x=0~63 y=0~31
画点
*/
void draw_pixel(uint8_t x, uint8_t y,ColorDef c)
{
    switch(c)
    {
        case RED:
            if(x < 32)
            {
                dat.r32[31 - y][0] |= (1 << x);
            }
            else
            {
                dat.r32[31 - y][1] |= (1 << (x - 32));
            }
            break;

        case GREEN:
            if(x < 32)
            {
                dat.g32[31 - y][0] |= (1 << x);
            }
            else
            {
                dat.g32[31 - y][1] |= (1 << (x - 32));
            }
            break;

        case BLUE:
            if(x < 32)
            {
                dat.b32[31 - y][0] |= (1 << x);
            }
            else
            {
                dat.b32[31 - y][1] |= (1 << (x - 32));
            }
            break;

        case YELLOW:
            if(x < 32)
            {
                dat.r32[31 - y][0] |= (1 << x);
                dat.g32[31 - y][0] |= (1 << x);
            }
            else
            {
                dat.r32[31 - y][1] |= (1 << (x - 32));
                dat.g32[31 - y][1] |= (1 << (x - 32));
            }
            break;

        case PURPLE:
            if(x < 32)
            {
                dat.r32[31 - y][0] |= (1 << x);
                dat.b32[31 - y][0] |= (1 << x);
            }
            else
            {
                dat.r32[31 - y][1] |= (1 << (x - 32));
                dat.b32[31 - y][1] |= (1 << (x - 32));
            }
            break;

        case CYAN:
            if(x < 32)
            {
                dat.b32[31 - y][0] |= (1 << x);
                dat.g32[31 - y][0] |= (1 << x);
            }
            else
            {
                dat.b32[31 - y][1] |= (1 << (x - 32));
                dat.g32[31 - y][1] |= (1 << (x - 32));
            }
            break;

        case WHITE:
            if(x < 32)
            {
                dat.r32[31 - y][0] |= (1 << x);
                dat.b32[31 - y][0] |= (1 << x);
                dat.g32[31 - y][0] |= (1 << x);
            }
            else
            {
                dat.r32[31 - y][1] |= (1 << (x - 32));
                dat.b32[31 - y][1] |= (1 << (x - 32));
                dat.g32[31 - y][1] |= (1 << (x - 32));
            }
            break;

        case BLACK:
            if(x < 32)
            {
                dat.r32[31 - y][0] &= ~(1 << x);
                dat.b32[31 - y][0] &= ~(1 << x);
                dat.g32[31 - y][0] &= ~(1 << x);
            }
            else
            {
                dat.r32[31 - y][1] &= ~(1 << (x - 32));
                dat.b32[31 - y][1] &= ~(1 << (x - 32));
                dat.g32[31 - y][1] &= ~(1 << (x - 32));
            }
            break;

        default:
            break;
    }
}

/*
deltax>x,deltay>y
画线
*/
void draw_line_rgb(uint8_t x, uint8_t y,uint8_t deltax, uint8_t deltay, ColorDef c)
{
    uint8_t i;
    if(deltax == 0)
    {
        for(i=0; i<deltay; i++)
        {
            draw_pixel(x, y + i, c);
        }
    }
    else if(deltay == 0)
    {
        for(i=0; i<deltax; i++)
        {
            draw_pixel(x + i, y, c);
        }
    }
}

void clean_line(uint8_t x, uint8_t y,uint8_t deltax, uint8_t deltay, ColorDef c)
{
	uint8_t i;
	if(deltax == 0)
	{
		for(i=0; i<deltay; i++)
		{
			draw_pixel(x, y + i, c);
		}
	}
		else if(deltay == 0)
		{
			for(i=0; i<deltax; i++)
			{
				draw_pixel(x + i, y, c);
			}
		}	
}

void Effects_one(void)
{
	uint8_t i=0;
	uint8_t j=64;
	for(i;i<32;i++)
	{
		if(i%4==0)
		{
			color_change();
		}
//		delay_ms(300);
		draw_line_rgb(i,0,0,32,(ColorDef)get_color());
		rt_thread_delay(25);
		clean_line(i,0,0,32,BLACK);
//		delay_ms(50);
	}
	for(j;j>32;j--)
	{
		if(j%8==0)
		{
			color_change();
		}
		draw_line_rgb(j,0,0,32,(ColorDef)get_color());
		rt_thread_delay(25);
		clean_line(j,0,0,32,BLACK);
	}
	i=0;
	j=64;
}

void Effects_two(void)
{
	uint8_t i=32;
	uint8_t j=32;
	for(i;i>0;i--)
	{
		if(i%4==0)
		{
			color_change();
		}
//		delay_ms(300);
		draw_line_rgb(i,0,0,32,(ColorDef)get_color());
		rt_thread_delay(25);
		clean_line(i,0,0,32,BLACK);
//		delay_ms(50);
	}
	for(j;j<64;j++)
	{
		if(j%4==0)
		{
			color_change();
		}
		draw_line_rgb(j,0,0,32,(ColorDef)get_color());
		rt_thread_delay(25);
		clean_line(j,0,0,32,BLACK);
	}
	i=32;
	j=32;
}

void Lighting_LED(ColorDef c)
{
	uint8_t i;
	switch(c){
		case 0:
			for(i;i<4;i++)
			{
				draw_line_rgb(i,0,0,32,RED);
				rt_thread_delay(50);
			}
			break;
		case 1:
			for(i;i<4;i++)
			{
				draw_line_rgb(i,0,0,32,GREEN);
				rt_thread_delay(50);
			}
			break;
		case 2:
		for(i;i<4;i++)
		{
			draw_line_rgb(i,0,0,32,BLUE);
			rt_thread_delay(50);
		}
			break;
		case 3:
		for(i;i<4;i++)
		{
			draw_line_rgb(i,0,0,32,YELLOW);
			rt_thread_delay(50);
		}
			break;
		case 4:
		for(i;i<4;i++)
		{
			draw_line_rgb(i,0,0,32,PURPLE);
			rt_thread_delay(50);
		}
			break;
		case 5:
		for(i;i<4;i++)
		{
			draw_line_rgb(i,0,0,32,CYAN);
			rt_thread_delay(50);
		}
			break;
		case 6:
		for(i;i<4;i++)
		{
//			i=i+2;
			draw_line_rgb(i,0,0,32,WHITE);
			rt_thread_delay(50);
		}
			break;
		default:
			break;
	}
}

void move_effect(ColorDef color)
{
    uint8_t i,j;
    uint8_t temp_bit;

    for(i=0;i<16;i++)
    {
        temp_bit = dat.move_buf[i][0] & 0x1;
        for(j=0;j<MOVE_BUFF-1;j++)
        {
            dat.move_buf[i][j] >>= 1;
            if(dat.move_buf[i][j + 1] & 0x1)
            {
                dat.move_buf[i][j] |= 0x80;
            }
            //rt_kprintf("%d %d=0x%x\n",i,j,dat.move_buf[i][j]);
        }
        dat.move_buf[i][MOVE_BUFF-1] >>= 1;
        if(temp_bit)
        {
            dat.move_buf[i][MOVE_BUFF-1] |= 0x80;
        }
    }

    for(i=0;i<16;i++)
    {
        for(j=0;j<8;j++)
        {
            switch(color)
            {
                case RED:
                    for(i=0; i<16; i++)
                    {
                        dat.r[i][j] = dat.move_buf[i][j];
                    }
                    break;

                case GREEN:
                    for(i=0; i<16; i++)
                    {
                        dat.g[i][j] = dat.move_buf[i][j];
                    }
                    break;

                case BLUE:
                    for(i=0; i<16; i++)
                    {
                        dat.b[i][j] = dat.move_buf[i][j];
                    }
                    break;

                case YELLOW:
                    for(i=0; i<16; i++)
                    {
                        dat.r[i][j] = dat.move_buf[i][j];
                        dat.g[i][j] = dat.move_buf[i][j];
                    }
                    break;

                case PURPLE:
                    for(i=0; i<16; i++)
                    {
                        dat.r[i][j] = dat.move_buf[i][j];
                        dat.b[i][j] = dat.move_buf[i][j];
                    }
                    break;

                case CYAN:
                    for(i=0; i<16; i++)
                    {
                        dat.g[i][j] = dat.move_buf[i][j];
                        dat.b[i][j] = dat.move_buf[i][j];
                    }
                    break;

                case WHITE:
                    for(i=0; i<16; i++)
                    {
                        dat.r[i][j] = dat.move_buf[i][j];
                        dat.g[i][j] = dat.move_buf[i][j];
                        dat.b[i][j] = dat.move_buf[i][j];
                    }
                    break;

                default:
                    break;

            }
        }
    }
}

/* x=0~7 y=0~16 */
static void disp8x16(uint8_t x, uint8_t y, uint8_t *pVal,ColorDef color)
{
    uint8_t i;

    switch(color)
    {
        case RED:
            for(i=0; i<16; i++)
            {
                dat.r[y + i][x] = *(pVal + i);
            }
            break;

        case GREEN:
            for(i=0; i<16; i++)
            {
                dat.g[y + i][x] = *(pVal + i);
            }
            break;

        case BLUE:
            for(i=0; i<16; i++)
            {
                dat.b[y + i][x] = *(pVal + i);
            }
            break;

        case YELLOW:
            for(i=0; i<16; i++)
            {
                dat.r[y + i][x] = *(pVal + i);
                dat.g[y + i][x] = *(pVal + i);
            }
            break;

        case PURPLE:
            for(i=0; i<16; i++)
            {
                dat.r[y + i][x] = *(pVal + i);
                dat.b[y + i][x] = *(pVal + i);
            }
            break;

        case CYAN:
            for(i=0; i<16; i++)
            {
                dat.g[y + i][x] = *(pVal + i);
                dat.b[y + i][x] = *(pVal + i);
            }
            break;

        case WHITE:
            for(i=0; i<16; i++)
            {
                dat.r[y + i][x] = *(pVal + i);
                dat.g[y + i][x] = *(pVal + i);
                dat.b[y + i][x] = *(pVal + i);
            }
            break;

        default:
            break;

    }
}

static void shift_dat(uint8_t row)
{
    static uint8_t i,j;
    static uint32_t datr_shit1,datr_shit2;
    static uint32_t datg_shit1,datg_shit2;
    static uint32_t datb_shit1,datb_shit2;

    for(i=0; i<2; i++)
    {
        datr_shit1 = dat.r32[row][i];
        datr_shit2 = dat.r32[row + 16][i];
        datg_shit1 = dat.g32[row][i];
        datg_shit2 = dat.g32[row + 16][i];
        datb_shit1 = dat.b32[row][i];
        datb_shit2 = dat.b32[row + 16][i];
        for(j=0; j<32; j++)
        {
            CTRL_CLK(0);
            if(datr_shit1 & 0x1)
            {
                DAT_R1(1);
            }
            else
            {
                DAT_R1(0);
            }

            if(datg_shit1 & 0x1)
            {
                DAT_G1(1);
            }
            else
            {
                DAT_G1(0);
            }

            if(datb_shit1 & 0x1)
            {
                DAT_B1(1);
            }
            else
            {
                DAT_B1(0);
            }

            if(datr_shit2 & 0x1)
            {
                DAT_R2(1);
            }
            else
            {
                DAT_R2(0);
            }

            if(datg_shit2 & 0x1)
            {
                DAT_G2(1);
            }
            else
            {
                DAT_G2(0);
            }

            if(datb_shit2 & 0x1)
            {
                DAT_B2(1);
            }
            else
            {
                DAT_B2(0);
            }
            CTRL_CLK(1);
            datr_shit1 >>= 1;
            datg_shit1 >>= 1;
            datb_shit1 >>= 1;
            datr_shit2 >>= 1;
            datg_shit2 >>= 1;
            datb_shit2 >>= 1;
        }
    }
    CTRL_CLK(0);
}

/* TIM中断，0.8ms调用，用于扫描 */
void led_scan(void)
{
    static uint8_t index = 0;

    shift_dat(index);
    //在锁存输出显示之前，将显示屏关闭，行切换后再打开，解决拖影问题
    LAT_LE_H;
    switch(index)
    {
        case 0x0:
            ROW_0;
            break;

        case 0x1:
            ROW_1;
            break;

        case 0x2:
            ROW_2;
            break;

        case 0x3:
            ROW_3;
            break;

        case 0x4:
            ROW_4;
            break;

        case 0x5:
            ROW_5;
            break;

        case 0x6:
            ROW_6;
            break;

        case 0x7:
            ROW_7;
            break;

        case 0x8:
            ROW_8;
            break;

        case 0x9:
            ROW_9;
            break;

        case 0xa:
            ROW_10;
            break;

        case 0xb:
            ROW_11;
            break;

        case 0xc:
            ROW_12;
            break;

        case 0xd:
            ROW_13;
            break;

        case 0xe:
            ROW_14;
            break;

        case 0xf:
            ROW_15;
            break;

        default:
            break;
    }
    LAT_LOCK;

    index++;
    if(index > 15)
    {
        index = 0;
    }
}

void color_init(void)
{
    dat.color = RED;
}

void color_change(void)
{
    dat.color++;
    if(dat.color == BLACK)
    {
        dat.color = RED;
    }
}

ColorDef get_color(void)
{
    return dat.color;
}

void GPIO_init(void)
{
//    static GPIO_InitTypeDef  GPIO_InitStructure;
////		GPIO_InitTypeDef  GPIO_InitStructure;
//    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA|RCC_APB2Periph_GPIOB, ENABLE);	 //使能

//    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1 |GPIO_Pin_0 |GPIO_Pin_3|GPIO_Pin_4 |GPIO_Pin_5 |GPIO_Pin_6 | GPIO_Pin_7 | GPIO_Pin_8 |GPIO_Pin_9 |GPIO_Pin_10 ;
//                                  
//    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; 		 //推挽输出
//    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;		 //IO口速度为50MHz
//    GPIO_Init(GPIOA, &GPIO_InitStructure);
//	
//	  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9 | GPIO_Pin_6 | GPIO_Pin_7;
//		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; 		 //推挽输出
//    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;		 //IO口速度为50MHz
//    GPIO_Init(GPIOB, &GPIO_InitStructure);
	
#if 0	
  GPIO_InitTypeDef  GPIO_InitStructure;
  	
  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA|RCC_APB2Periph_GPIOB, ENABLE);	 //使能PC,PD端口时钟
	
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 |GPIO_Pin_1 |GPIO_Pin_3|GPIO_Pin_4 |GPIO_Pin_5 |GPIO_Pin_6 | GPIO_Pin_7 | GPIO_Pin_8 |GPIO_Pin_9 |GPIO_Pin_10 ;				 //LED0-->PC.12 端口配置
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; 		 //推挽输出
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;		 //IO口速度为50MHz
  GPIO_Init(GPIOA, &GPIO_InitStructure);					 //根据设定参数初始化GPIOA.8
//  GPIO_SetBits(GPIOC,GPIO_Pin_12);						 //PA.8 输出高

  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9 | GPIO_Pin_6 | GPIO_Pin_7;	    		 //LED1-->PD.2 端口配置, 推挽输出
  GPIO_Init(GPIOB, &GPIO_InitStructure);	  				 //推挽输出 ，IO口速度为50MHz
//  GPIO_SetBits(GPIOD,GPIO_Pin_2); 						 //PD.2 输出高 

#else
	GPIO_InitTypeDef GPIO_Initure;
  __HAL_RCC_GPIOB_CLK_ENABLE();           //开启GPIOB时钟
	__HAL_RCC_GPIOA_CLK_ENABLE();           //开启GPIOB时钟
	
	GPIO_Initure.Pin=GPIO_PIN_1|GPIO_PIN_3|GPIO_PIN_4|GPIO_PIN_5|GPIO_PIN_6|GPIO_PIN_7|GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_10;
	GPIO_Initure.Mode=GPIO_MODE_OUTPUT_PP;
	GPIO_Initure.Pull=GPIO_PULLUP;          //上拉
	GPIO_Initure.Speed=GPIO_SPEED_FREQ_HIGH;
	HAL_GPIO_Init(GPIOA,&GPIO_Initure);
//	HAL_GPIO_WritePin(GPIOA,GPIO_PIN_0,0);  //低电平使能显示屏    GPIO_PIN_0|
	
	GPIO_Initure.Pin=GPIO_PIN_6|GPIO_PIN_7|GPIO_PIN_9;
	HAL_GPIO_Init(GPIOB,&GPIO_Initure);
	
#endif	

}

void disp_background(uint8_t index,ColorDef c)
{
    uint8_t *pNum;
    if(index == 0)  //led clr
    {
        memset(dat.r32,0,LED_BUFF_SIZE);
    }
    else if(index == 1)  //disp symbol
    {
        pNum = &gap[0<<4];//4
        disp8x16(2,LINE_1,pNum,dot_color);//2
        disp8x16(5,LINE_1,pNum,dot_color);//5

    }
		else if(index == 5)
		{
			switch(c)
			{
				case 0:
					memset(dat.r32,0,LED_BUFF_SIZE);
          memcpy(dat.r32,(const void *)&AA[0],sizeof(dat.r32));
          break;
				
				case 1:
                memset(dat.r32,0,LED_BUFF_SIZE);
                memcpy(dat.g32,(const void *)&AA[0],sizeof(dat.r32));
                break;

            case 2:
                memset(dat.r32,0,LED_BUFF_SIZE);
                memcpy(dat.b32,(const void *)&AA[0],sizeof(dat.r32));
                break;

            case 3:
                memset(dat.r32,0,LED_BUFF_SIZE);
                memcpy(dat.r32,(const void *)&AA[0],sizeof(dat.r32));
                memcpy(dat.g32,(const void *)&AA[0],sizeof(dat.r32));
                break;

            case 4:
                memset(dat.r32,0,LED_BUFF_SIZE);
                memcpy(dat.r32,(const void *)&AA[0],sizeof(dat.r32));
                memcpy(dat.b32,(const void *)&AA[0],sizeof(dat.r32));
                break;

            case 5:
                memset(dat.r32,0,LED_BUFF_SIZE);
                memcpy(dat.g32,(const void *)&AA[0],sizeof(dat.r32));
                memcpy(dat.b32,(const void *)&AA[0],sizeof(dat.r32));
                break;

            case 6:
                memset(dat.r32,0,LED_BUFF_SIZE);
                memcpy(dat.r32,(const void *)&AA[0],sizeof(dat.r32));
                memcpy(dat.g32,(const void *)&AA[0],sizeof(dat.r32));
                memcpy(dat.b32,(const void *)&AA[0],sizeof(dat.r32));
                break;

            default:
                break;
			}
		}
    else if(index == 6) //disp zhufu
    {
        switch(c)
        {
            case 0:
                memset(dat.r32,0,LED_BUFF_SIZE);     //把dat.r32中的LED_BUFF_SIZE位置为零
                memcpy(dat.r32,(const void *)&zhufu[0],sizeof(dat.r32));  //把&zhufu[0]中的dat.r32个字节复制到dat.r32中所指区域
                break;

            case 1:
                memset(dat.r32,0,LED_BUFF_SIZE);
                memcpy(dat.g32,(const void *)&zhufu[0],sizeof(dat.r32));
                break;

            case 2:
                memset(dat.r32,0,LED_BUFF_SIZE);
                memcpy(dat.b32,(const void *)&zhufu[0],sizeof(dat.r32));
                break;

            case 3:
                memset(dat.r32,0,LED_BUFF_SIZE);
                memcpy(dat.r32,(const void *)&zhufu[0],sizeof(dat.r32));
                memcpy(dat.g32,(const void *)&zhufu[0],sizeof(dat.r32));
                break;

            case 4:
                memset(dat.r32,0,LED_BUFF_SIZE);
                memcpy(dat.r32,(const void *)&zhufu[0],sizeof(dat.r32));
                memcpy(dat.b32,(const void *)&zhufu[0],sizeof(dat.r32));
                break;

            case 5:
                memset(dat.r32,0,LED_BUFF_SIZE);
                memcpy(dat.g32,(const void *)&zhufu[0],sizeof(dat.r32));
                memcpy(dat.b32,(const void *)&zhufu[0],sizeof(dat.r32));
                break;

            case 6:
                memset(dat.r32,0,LED_BUFF_SIZE);
                memcpy(dat.r32,(const void *)&zhufu[0],sizeof(dat.r32));
                memcpy(dat.g32,(const void *)&zhufu[0],sizeof(dat.r32));
                memcpy(dat.b32,(const void *)&zhufu[0],sizeof(dat.r32));
                break;

            default:
                break;
        }
    }
    else if(index == 7) //disp happy
    {
        switch(c)
        {
            case 0:
                memset(dat.r32,0,sizeof(dat));
                memcpy(dat.r32,(const void *)&happy[0],sizeof(dat.r32));
                break;

            case 1:
                memset(dat.r32,0,sizeof(dat));
                memcpy(dat.g32,(const void *)&happy[0],sizeof(dat.r32));
                break;

            case 2:
                memset(dat.r32,0,sizeof(dat));
                memcpy(dat.b32,(const void *)&happy[0],sizeof(dat.r32));
                break;

            case 3:
                memset(dat.r32,0,sizeof(dat));
                memcpy(dat.r32,(const void *)&happy[0],sizeof(dat.r32));
                memcpy(dat.g32,(const void *)&happy[0],sizeof(dat.r32));
                break;

            case 4:
                memset(dat.r32,0,sizeof(dat));
                memcpy(dat.r32,(const void *)&happy[0],sizeof(dat.r32));
                memcpy(dat.b32,(const void *)&happy[0],sizeof(dat.r32));
                break;

            case 5:
                memset(dat.r32,0,sizeof(dat));
                memcpy(dat.g32,(const void *)&happy[0],sizeof(dat.r32));
                memcpy(dat.b32,(const void *)&happy[0],sizeof(dat.r32));
                break;

            case 6:
                memset(dat.r32,0,sizeof(dat));
                memcpy(dat.r32,(const void *)&happy[0],sizeof(dat.r32));
                memcpy(dat.g32,(const void *)&happy[0],sizeof(dat.r32));
                memcpy(dat.b32,(const void *)&happy[0],sizeof(dat.r32));
                break;

            default:
                break;
        }
    }
    else if(index == 8) //disp happy
    {
        switch(c)
        {
            case 0:
                memset(dat.r32,0,sizeof(dat));
                memcpy(dat.r32,(const void *)&kands[0],sizeof(dat.r32));
                break;

            case 1:
                memset(dat.r32,0,sizeof(dat));
                memcpy(dat.g32,(const void *)&kands[0],sizeof(dat.r32));
                break;

            case 2:
                memset(dat.r32,0,sizeof(dat));
                memcpy(dat.b32,(const void *)&kands[0],sizeof(dat.r32));
                break;

            case 3:
                memset(dat.r32,0,sizeof(dat));
                memcpy(dat.r32,(const void *)&kands[0],sizeof(dat.r32));
                memcpy(dat.g32,(const void *)&kands[0],sizeof(dat.r32));
                break;

            case 4:
                memset(dat.r32,0,sizeof(dat));
                memcpy(dat.r32,(const void *)&kands[0],sizeof(dat.r32));
                memcpy(dat.b32,(const void *)&kands[0],sizeof(dat.r32));
                break;

            case 5:
                memset(dat.r32,0,sizeof(dat));
                memcpy(dat.g32,(const void *)&kands[0],sizeof(dat.r32));
                memcpy(dat.b32,(const void *)&kands[0],sizeof(dat.r32));
                break;

            case 6:
                memset(dat.r32,0,sizeof(dat));
                memcpy(dat.r32,(const void *)&kands[0],sizeof(dat.r32));
                memcpy(dat.g32,(const void *)&kands[0],sizeof(dat.r32));
                memcpy(dat.b32,(const void *)&kands[0],sizeof(dat.r32));
                break;

            default:
                break;
        }
    }
    else if(index == 9) //disp ship
    {
        switch(c)
        {
            case 0:
                memset(dat.r32,0,sizeof(dat));
                memcpy(dat.r32,(const void *)&ship[0],sizeof(dat.r32));
                break;

            case 1:
                memset(dat.r32,0,sizeof(dat));
                memcpy(dat.g32,(const void *)&ship[0],sizeof(dat.r32));
                break;

            case 2:
                memset(dat.r32,0,sizeof(dat));
                memcpy(dat.b32,(const void *)&ship[0],sizeof(dat.r32));
                break;

            case 3:
                memset(dat.r32,0,sizeof(dat));
                memcpy(dat.r32,(const void *)&ship[0],sizeof(dat.r32));
                memcpy(dat.g32,(const void *)&ship[0],sizeof(dat.r32));
                break;

            case 4:
                memset(dat.r32,0,sizeof(dat));
                memcpy(dat.r32,(const void *)&ship[0],sizeof(dat.r32));
                memcpy(dat.b32,(const void *)&ship[0],sizeof(dat.r32));
                break;

            case 5:
                memset(dat.r32,0,sizeof(dat));
                memcpy(dat.g32,(const void *)&ship[0],sizeof(dat.r32));
                memcpy(dat.b32,(const void *)&ship[0],sizeof(dat.r32));
                break;

            case 6:
                memset(dat.r32,0,sizeof(dat));
                memcpy(dat.r32,(const void *)&ship[0],sizeof(dat.r32));
                memcpy(dat.g32,(const void *)&ship[0],sizeof(dat.r32));
                memcpy(dat.b32,(const void *)&ship[0],sizeof(dat.r32));
                break;

            default:
                break;
        }
    }
}


/* *************************************** */
/* MSH CMD */
//extern void led_disp_reinit(void);
//long led(uint8_t argc, char **argv)
//{
//    static uint8_t x,y,v,c;
//    uint8_t *pNum;

//    if(argc == 2)
//    {
//        const char *cx = argv[1];
//        if (!strcmp(cx, "clr"))
//        {
//            rt_kprintf("clr\r\n");
//            memset(dat.r32,0,sizeof(dat));
//        }
//        else if (!strcmp(cx, "rectr"))
//        {
//            rt_kprintf("rectr\r\n");
//            memcpy(dat.r32,(const void *)&rect[0],sizeof(dat.r32));
//        }
//        else if (!strcmp(cx, "rectg"))
//        {
//            rt_kprintf("rectg\r\n");
//            memcpy(dat.g32,(const void *)&rect[0],sizeof(dat.r32));
//        }
//        else if (!strcmp(cx, "rectb"))
//        {
//            rt_kprintf("rectb\r\n");
//            memcpy(dat.b32,(const void *)&rect[0],sizeof(dat.r32));
//        }
//        else if (!strcmp(cx, "ship"))
//        {
//            rt_kprintf("ship\r\n");
//            memcpy(dat.b32,(const void *)&ship[0],sizeof(dat.r32));
//        }
//        else if (!strcmp(cx, "move"))
//        {
//            rt_kprintf("move\r\n");
//            move_effect(RED);
//        }
//        else if (!strcmp(cx, "size"))
//        {
//            rt_kprintf("dat=%d\n",sizeof(dat));
//            rt_kprintf("dat.r=%d\n",sizeof(dat.r));
//            rt_kprintf("dat.r32=%d\n",sizeof(dat.r32));
//            rt_kprintf("dat.move=%d\n",sizeof(dat.move_buf));
//            rt_kprintf("dat.color=%d\n",sizeof(dat.color));
//        }
//    }

//    if(argc == 3)
//    {
//        const char *cx = argv[1];
//        const char *cc = argv[2];

//        c = atoi((const char *)cc);

//        if(!strcmp(cx, "c"))
//        {
//            rt_kprintf("color=%d\r\n",c);
//            dat.color = (ColorDef)c;
//            led_disp_reinit();
//        }
//        return 0;
//    }

//    if(argc == 5)
//    {
//        const char *cx = argv[1];
//        const char *cy = argv[2];
//        const char *cc = argv[3];
//        const char *cv = argv[4];

//        x = atoi((const char *)cx);
//        y = atoi((const char *)cy);
//        c = atoi((const char *)cc);
//        v = atoi((const char *)cv);

//        rt_kprintf("%d,%d,%d,%d ",x,y,c,v);

//        if(v <= 10)
//        {
//            pNum = &num[v << 4];
//            disp8x16(x,y,pNum,(ColorDef)c);
//            rt_kprintf("num\r\n");
//        }
//        return 0;
//    }
//    return 0;
//}
//FINSH_FUNCTION_EXPORT(led, led test);
//MSH_CMD_EXPORT(led, led test);

